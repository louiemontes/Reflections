What happens when you initialize a repository? Why do you need to do it?

    By viewing a diff between two version of a file I was helped finding a bug by being allowed to see only the changes and focus on what might have went wrong, like how a horse with blinders on its head focuses only the race course or army its about to charge into.  

How is the staging area different from the working directory and the repository?
What value do you think it offers?

    The staging area is different from the working directory because it is the space Git makes to prepare files for adding to a repository while the working directory is just where source code is located and has nothing ever tracked in it by Git.  The staging area is different from the repository because the repository has files in it that are all saved via the checkpoints of commits or a commit while the staging area only prepares files to possibly be included in this kind of tracking.   

How can you use the staging area to make sure you have one commit per logical
change?

    The pros of manually choosing when to create a commit or checkpoint like in Git over having versions saved automatically is that if a developer is careful enough he/she can have logical versions to fall back on or compare should something go wrong or have a complicated product outcome.  Also, the commits when Git is used correctly, version history is not cluttered with unnescessary checkpoints because some other arbirtatry metric was used for auto-saving: like time intervals or sustained idleness.  
    The cons of manually choosing commits is that developer discresion is not always the most sound and may forget to commit.

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

    I think Git allows saving multiple files in one commit because as a version control system meant for code it understands the inter-dependent nature of larger coding applications typically needing more than one file to run and hence was made allowable to track many files at once so that the developer can catch all the nuances of changes among many files and debug.  Google Docs, however, makes sense to not need this ability as its meant for files like a research papers or slide shows, where just one worked on file is usually ever used.  

How do the diagrams help you visualize the branch structure?

    You can type 'git log' to see the full list of commits that have happened on a repo, and you can use 'git diff [latest id] [older change] to see deletions and insertions.'

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

    Using a VCS can make me more confident to make changes that could break something because as long as I make a commit before trying something crazy with my code, I can always go back to an older version and see what wrong or just use an older version instead if my code feels changed beyond repair.  VCS works like a safety cable would for astronauts needing to fix something on their space ship, as long as their cable works they can generally always come back to safety.  

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?

    I want to try using git to be an alpha ass programmer.  Okay I'm kidding, but I do want to not be laughed out of the park when I wreck IcedDev's code base for pagenodes accidently. 